//! This is the module Awesome.toml
use crate::exec::prompt;
use crate::prelude::*;
use crate::VERSION;
use serde_derive::Deserialize;
use std::fs;
use std::path::Path;

mod runner;

// --- re-exports
pub use runner::*; // Wide for now.

// --- Consts
const AWESOME_TMPL: &str = include_str!("../../tmpl/Awesome.toml");
const AWESOME_FILE_NAME: &str = "Awesome.toml";
const SRC_TAURI_DIR: &str = "src-tauri";
const PACKAGE_JSON_FILE: &str = "package.json";

// --- Config Types
#[derive(Debug, Deserialize)]
pub struct Config {
	pub cli_version: Option<String>,
	pub dev: Option<Dev>,
}

#[derive(Debug, Deserialize)]
pub struct Dev {
	pub runners: Option<Vec<Runner>>,
}

// --- Awesome.toml generator / parser

pub fn ensure_awesome_toml(root_dir: &Path) -> Result<Config> {
	// --- Check that we run in the root folder.
	if !root_dir.join(SRC_TAURI_DIR).is_dir() && !root_dir.join(PACKAGE_JSON_FILE).is_file() {
		return Err(Error::DirNotValid);
	}

	// --- Create if not present.
	let awesome_file = root_dir.join(AWESOME_FILE_NAME);
	if !awesome_file.is_file() {
		create_awesome_toml(&awesome_file)?;
	}

	// --- Load and validate.
	let toml_str = fs::read_to_string(&awesome_file)?;
	parse_awesome_toml(&toml_str).or_else(|_| {
		let res = prompt(
			"Awesome.toml needs to be udpated (probably an old format).\nDo you want to udpate the Awesome.toml Y/N (Y)? ",
			Some("y"),
		)?;

		if res == "Y" || res == "y" {
			// Backup the old file.
			let ver = VERSION.replace('.', "-");
			let backup_file_name = f!(".Awesome-backup-before-{ver}.toml");
			let old_file = root_dir.join(&backup_file_name);
			fs::copy(&awesome_file, old_file)?;
			println!("Backup not working Awesome.toml as '{backup_file_name}'");

			// Create the new Awesome.toml
			println!("Creating new Awesome.toml");
			create_awesome_toml(&awesome_file)?;
			let toml_str = fs::read_to_string(&awesome_file)?;

			// Parse and return.
			parse_awesome_toml(&toml_str)
		} else {
			Err(Error::AwesomeTomlInvalid)
		}
	})
}

fn create_awesome_toml(awesome_file: &Path) -> Result<()> {
	let mut content = String::new();
	content.push_str(&format!(
		r#"# Generated by 'awesome-app' command line.
awesome_app_version = "{VERSION}"

"#
	));
	content.push_str(AWESOME_TMPL);

	fs::write(awesome_file, &content)?;

	Ok(())
}

fn parse_awesome_toml(toml_str: &str) -> Result<Config> {
	let config = toml::from_str::<Config>(toml_str).map_err(Error::FailParsingConfig)?;

	let number_of_dev_runners = config
		.dev
		.as_ref()
		.and_then(|d| d.runners.as_ref())
		.map(|rs| rs.len())
		.unwrap_or_default();

	if number_of_dev_runners == 0 {
		Err(Error::AwesomeTomlInvalid)
	} else {
		Ok(config)
	}
}

// region:    --- Tests
#[cfg(test)]
#[path = "../_tests/tests_config.rs"]
mod tests;
// endregion: --- Tests
